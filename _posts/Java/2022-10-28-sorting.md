---
title:  "Sorting"
date:   2022-10-28 22:16:00
categories: ['Java']
tags: ['Java']
toc: true
---
{::options parse_block_html="true" /}

Soring based on simple fields are easy to do when it comes to Jave 8. But sorting based on Objects inside a list of 
Objects needs attention


<details>
    <summary> 
    View Class Structure 
    </summary>

```java
public class EventComments {
    private String facilityId;
    private String orderId;
    private List<SomeStats> someStats;//Weird Scenario, only one element in the list
    private String sectionName;
    private SomeClass someClass;//Type Class
}

public class SomeStats {
    private String eventid;
    private String eventType;
    private String timeDtDisplay;
    private String eventsComments;
}

public class SomeClass {
    Integer index;
    Integer noOfYears;
    String someStr;
}
```
</details>

---
<details>
    <summary> 
    View Sample Data
    </summary>

```json
EventComments(facilityId=11019, orderId=5b571d0a-1124-45b2-9985-373799d97a96, 
	someStats=[
		SomeStats(eventid=1, eventType=Initial Entry, timeDtDisplay=09:17, 
		eventsComments=09:17 EDT Initial Entry Joe, Dow RM)], 
	sectionName=null, 
	someClass=SomeClass(index=101, noOfYears=5, someStr=one O one)
)

EventComments(facilityId=11019, orderId=5b571d0a-1124-45b2-9985-373799d97a96, 
	someStats=[
		SomeStats(eventid=2, eventType=Updated by, timeDtDisplay=09:19, 
		eventsComments=09:19 EDT Updated by Joe, Dow RM)], 
	sectionName=null, 
	someClass=SomeClass(index=201, noOfYears=9, someStr=Two O one)
)
```
</details>


If we have a list of `EventComments` and the sort is based on the following criterion :-

* if we wish to compare based on one arbitrary field `index` inside SomeClass object

```java
eventCommentsList.sort((object1, object2) -> {
    return object1.getSomeClass().getIndex().compareTo(object2.getSomeClass().getIndex());
});
```

* if the requirement is to compare (reversed sort) based on a field `timeDtDisplay` in the value of first element of the list Object `List<SomeStats> someStats`. 

> Notice the placement of the object2 in comparison to object1 for reverse sorting.

```java
eventCommentsList.sort((object1, object2) -> {
    return object2.getSomeStats().get(0).getTimeDtDisplay().compareTo(object1.getSomeStats().get(0).getTimeDtDisplay());
});
```

* if the requirement is to compare based on some field `index` of `SomeClass` Object and if the `index` is equal, 
then use the field `timeDtDisplay` from the first element of the List of `SomeStats` 

```java
eventCommentsList.sort(
    (EventComments o1, EventComments o2) -> {
       if(o1.getSomeClass().getIndex() > o2.getSomeClass().getIndex())
           return -1;
       else if(o1.getSomeClass().getIndex() < o2.getSomeClass().getIndex())
           return 1;
       else {
           return (o2.getSomeStats().get(0).getTimeDtDisplay().compareTo(o1.getSomeStats().get(0).getTimeDtDisplay()));
       }
    });
```

Please notice that the code has been reduced from this longer version, where the Comparator interface is being implemented the older way.
```java
eventCommentsList.sort(new Comparator<EventComments>() {
        @Override
        public int compare(EventComments o1, EventComments o2) {
           if(o1.getSomeClass().getIndex() > o2.getSomeClass().getIndex())
               return -1;
           else if(o1.getSomeClass().getIndex() < o2.getSomeClass().getIndex())
               return 1;
           else {
               return (o2.getSomeStats().get(0).getTimeDtDisplay().compareTo(o1.getSomeStats().get(0).getTimeDtDisplay()));
           }
        }
    });
```