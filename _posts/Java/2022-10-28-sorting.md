---
title:  "Sorting"
date:   2022-10-28 22:16:00
categories: ['Java']
tags: ['Java']
toc: true
---

Soring based on simple fields are easy to do when it comes to Jave 8. But sorting based on Objects inside a list of 
Objects needs attention



<details>
<summary> 
    View Class Structure 
</summary>

{% gist nitinkc/251f66a8b112373d044a98f2590586fe %}
</details>


---

<details>

<summary>
    View Sample Data
</summary>

```json
EventComments(facilityId=11019, orderId=5b571d0a-1124-45b2-9985-373799d97a96, 
	someStats=[
		SomeStats(eventid=1, eventType=Initial Entry, timeDtDisplay=09:17, 
		eventsComments=09:17 EDT Initial Entry Joe, Dow RM)], 
	sectionName=null, 
	someClass=SomeClass(index=101, noOfYears=5, someStr=one O one)
)

EventComments(facilityId=11019, orderId=5b571d0a-1124-45b2-9985-373799d97a96, 
	someStats=[
		SomeStats(eventid=2, eventType=Updated by, timeDtDisplay=09:19, 
		eventsComments=09:19 EDT Updated by Joe, Dow RM)], 
	sectionName=null, 
	someClass=SomeClass(index=201, noOfYears=9, someStr=Two O one)
)
```
</details>


If we have a list of `EventComments` and the sort is based on the following criterion :-

* if we wish to compare based on one arbitrary field `index` inside SomeClass object

```java
eventCommentsList.sort((object1, object2) -> {
    return object1.getSomeClass().getIndex().compareTo(object2.getSomeClass().getIndex());
});
```

* if the requirement is to compare (reversed sort) based on a field `timeDtDisplay` in the value of first element of the list Object `List<SomeStats> someStats`. 

> Notice the placement of the object2 in comparison to object1 for reverse sorting.

```java
eventCommentsList.sort((object1, object2) -> {
    return object2.getSomeStats().get(0).getTimeDtDisplay().compareTo(object1.getSomeStats().get(0).getTimeDtDisplay());
});
```

* if the requirement is to compare based on some field `index` of `SomeClass` Object and if the `index` is equal, 
then use the field `timeDtDisplay` from the first element of the List of `SomeStats` 

```java
eventCommentsList.sort(
    (EventComments o1, EventComments o2) -> {
       if(o1.getSomeClass().getIndex() > o2.getSomeClass().getIndex())
           return -1;
       else if(o1.getSomeClass().getIndex() < o2.getSomeClass().getIndex())
           return 1;
       else {
           return (o2.getSomeStats().get(0).getTimeDtDisplay().compareTo(o1.getSomeStats().get(0).getTimeDtDisplay()));
       }
    });
```

Please notice that the code has been reduced from this longer version, where the Comparator interface is being implemented the older way.

```java
eventCommentsList.sort(new Comparator<EventComments>() {
        @Override
        public int compare(EventComments o1, EventComments o2) {
           if(o1.getSomeClass().getIndex() > o2.getSomeClass().getIndex())
               return -1;
           else if(o1.getSomeClass().getIndex() < o2.getSomeClass().getIndex())
               return 1;
           else {
               return (o2.getSomeStats().get(0).getTimeDtDisplay().compareTo(o1.getSomeStats().get(0).getTimeDtDisplay()));
           }
        }
    });
```

##### Sorting a Primitive list
{% gist nitinkc/d55b4541f27fc0bfd86f122d35c2b527 %}

##### Sorting a list of certain Type
{% gist nitinkc/bb52e836bb4a5472959ebbd5c95375f5 %}


##### Sorting a set
{% gist nitinkc/61476aad3b16d3c29e843553788e640b %}

### Filthy way of sorting a list

```java
// Sort method under Collection takes the same comparator
list.sort(Comparator.comparing(String::toString, (String a, String b) -> Integer.parseInt(a.substring(2)) - Integer.parseInt(b.substring(2))));
list.sort(Comparator.comparing(String::toString,comparator.reversed()));

// Single Line Implementation using Collections Arrays Utility Class
Collections.sort(list, ((String a, String b) -> Integer.parseInt(a.substring(2)) - Integer.parseInt(b.substring(2))));

Comparator<String>  comparator = (String a, String b) -> Integer.parseInt(a.substring(2)) - Integer.parseInt(b.substring(2));
Collections.sort(list, comparator);
list.sort(comparator);

//Prior to Java 8, using anonymous class
list.sort(new Comparator<String>() {
          @Override
          public int compare(String o1, String o2) {
              int interstateNumber1 = Integer.parseInt(o1.substring(2));
              int interstateNumber2 = Integer.parseInt(o2.substring(2));

              if (interstateNumber1 > interstateNumber2) {
                  return 1;
              } else if (interstateNumber1 < interstateNumber2){
                  return -1;
              }
              else{
                  throw new IllegalArgumentException("Two Interstates with same name in a Same City");
              }
          }
      });
```